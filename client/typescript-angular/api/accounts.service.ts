/**
 * Consumer Data Standards
 * API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right
 *
 * OpenAPI spec version: 1-oas3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ErrorList } from '../model/errorList';
import { RequestAccountIds } from '../model/requestAccountIds';
import { ResponseBankingAccount } from '../model/responseBankingAccount';
import { ResponseBankingAccounts } from '../model/responseBankingAccounts';
import { ResponseBankingAccountsBalances } from '../model/responseBankingAccountsBalances';
import { ResponseBankingTransactionDetail } from '../model/responseBankingTransactionDetail';
import { ResponseBankingTransactions } from '../model/responseBankingTransactions';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class AccountsService {

    protected basePath = 'https://data.provider.com.au/cds-au/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get Account Detail
     * Obtain detailed information on a single account
     * @param accountId A tokenised identifier for the account which is unique but not shareable
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAccountDetail(accountId: string, observe?: 'body', reportProgress?: boolean): Observable<ResponseBankingAccount>;
    public getAccountDetail(accountId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBankingAccount>>;
    public getAccountDetail(accountId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBankingAccount>>;
    public getAccountDetail(accountId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountDetail.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.basePath}/banking/accounts/${encodeURIComponent(String(accountId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Transaction Detail
     * Obtain detailed information on a transaction for a specific account
     * @param accountId The account id token that is used to uniquely represent the account
     * @param transactionId The unique identifier for the specific transaction for which details are being requested
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionDetail(accountId: string, transactionId: string, observe?: 'body', reportProgress?: boolean): Observable<ResponseBankingTransactionDetail>;
    public getTransactionDetail(accountId: string, transactionId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBankingTransactionDetail>>;
    public getTransactionDetail(accountId: string, transactionId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBankingTransactionDetail>>;
    public getTransactionDetail(accountId: string, transactionId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTransactionDetail.');
        }
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling getTransactionDetail.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.basePath}/banking/accounts/${encodeURIComponent(String(accountId))}/transactions/${encodeURIComponent(String(transactionId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Transactions For Account
     * Obtain transactions for a specific account
     * @param accountId ID of the account to get transactions for.  Must have previously been returned by one of the account list end points.
     * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type
     * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type
     * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount
     * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount
     * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string
     * @param page Page of results to request (standard pagination)
     * @param pageSize Page size to request. Default is 25 (standard pagination)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactions(accountId: string, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<ResponseBankingTransactions>;
    public getTransactions(accountId: string, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBankingTransactions>>;
    public getTransactions(accountId: string, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBankingTransactions>>;
    public getTransactions(accountId: string, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTransactions.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('start-time', <any>startTime);
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('end-time', <any>endTime);
        }
        if (minAmount !== undefined && minAmount !== null) {
            queryParameters = queryParameters.set('min-amount', <any>minAmount);
        }
        if (maxAmount !== undefined && maxAmount !== null) {
            queryParameters = queryParameters.set('max-amount', <any>maxAmount);
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('page-size', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.basePath}/banking/accounts/${encodeURIComponent(String(accountId))}/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Accounts
     * Obtain a list of accounts
     * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
     * @param isOwned Filters accounts based on whether they are owned by the authorised customer
     * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param page Page of results to request (standard pagination)
     * @param pageSize Page size to request. Default is 25 (standard pagination)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listAccounts(openStatus?: string, isOwned?: string, productCategory?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<ResponseBankingAccounts>;
    public listAccounts(openStatus?: string, isOwned?: string, productCategory?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBankingAccounts>>;
    public listAccounts(openStatus?: string, isOwned?: string, productCategory?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBankingAccounts>>;
    public listAccounts(openStatus?: string, isOwned?: string, productCategory?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (openStatus !== undefined && openStatus !== null) {
            queryParameters = queryParameters.set('open-status', <any>openStatus);
        }
        if (isOwned !== undefined && isOwned !== null) {
            queryParameters = queryParameters.set('is-owned', <any>isOwned);
        }
        if (productCategory !== undefined && productCategory !== null) {
            queryParameters = queryParameters.set('product-category', <any>productCategory);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('page-size', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.basePath}/banking/accounts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Bulk Balances
     * Obtain balances for multiple, filtered accounts
     * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
     * @param isOwned Filters accounts based on whether they are owned by the authorised customer
     * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param page Page of results to request (standard pagination)
     * @param pageSize Page size to request. Default is 25 (standard pagination)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listBalancesBulk(openStatus?: string, isOwned?: string, productCategory?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<ResponseBankingAccountsBalances>;
    public listBalancesBulk(openStatus?: string, isOwned?: string, productCategory?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBankingAccountsBalances>>;
    public listBalancesBulk(openStatus?: string, isOwned?: string, productCategory?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBankingAccountsBalances>>;
    public listBalancesBulk(openStatus?: string, isOwned?: string, productCategory?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (openStatus !== undefined && openStatus !== null) {
            queryParameters = queryParameters.set('open-status', <any>openStatus);
        }
        if (isOwned !== undefined && isOwned !== null) {
            queryParameters = queryParameters.set('is-owned', <any>isOwned);
        }
        if (productCategory !== undefined && productCategory !== null) {
            queryParameters = queryParameters.set('product-category', <any>productCategory);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('page-size', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.basePath}/banking/accounts/balances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Balances For Specific Accounts
     * Obtain balances for a specified list of accounts
     * @param body The list of account IDs to obtain information for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listBalancesSpecificAccounts(body: RequestAccountIds, observe?: 'body', reportProgress?: boolean): Observable<ResponseBankingAccountsBalances>;
    public listBalancesSpecificAccounts(body: RequestAccountIds, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBankingAccountsBalances>>;
    public listBalancesSpecificAccounts(body: RequestAccountIds, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBankingAccountsBalances>>;
    public listBalancesSpecificAccounts(body: RequestAccountIds, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling listBalancesSpecificAccounts.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post(`${this.basePath}/banking/accounts/balances`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Transactions For Multiple Accounts
     * Obtain transactions for multiple, filtered accounts
     * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
     * @param isOwned Filters accounts based on whether they are owned by the authorised customer
     * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type
     * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type
     * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount
     * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount
     * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string
     * @param page Page of results to request (standard pagination)
     * @param pageSize Page size to request. Default is 25 (standard pagination)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listTransactionsBulk(openStatus?: string, isOwned?: string, productCategory?: string, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<ResponseBankingTransactions>;
    public listTransactionsBulk(openStatus?: string, isOwned?: string, productCategory?: string, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBankingTransactions>>;
    public listTransactionsBulk(openStatus?: string, isOwned?: string, productCategory?: string, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBankingTransactions>>;
    public listTransactionsBulk(openStatus?: string, isOwned?: string, productCategory?: string, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (openStatus !== undefined && openStatus !== null) {
            queryParameters = queryParameters.set('open-status', <any>openStatus);
        }
        if (isOwned !== undefined && isOwned !== null) {
            queryParameters = queryParameters.set('is-owned', <any>isOwned);
        }
        if (productCategory !== undefined && productCategory !== null) {
            queryParameters = queryParameters.set('product-category', <any>productCategory);
        }
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('start-time', <any>startTime);
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('end-time', <any>endTime);
        }
        if (minAmount !== undefined && minAmount !== null) {
            queryParameters = queryParameters.set('min-amount', <any>minAmount);
        }
        if (maxAmount !== undefined && maxAmount !== null) {
            queryParameters = queryParameters.set('max-amount', <any>maxAmount);
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('page-size', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get(`${this.basePath}/banking/accounts/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Transactions For Specific Accounts
     * Obtain transactions for a specified list of transactions.
     * @param body The list of account IDs to obtain information for
     * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type
     * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type
     * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount
     * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount
     * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string
     * @param page Page of results to request (standard pagination)
     * @param pageSize Page size to request. Default is 25 (standard pagination)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listTransactionsSpecificAccounts(body: RequestAccountIds, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<ResponseBankingTransactions>;
    public listTransactionsSpecificAccounts(body: RequestAccountIds, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseBankingTransactions>>;
    public listTransactionsSpecificAccounts(body: RequestAccountIds, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseBankingTransactions>>;
    public listTransactionsSpecificAccounts(body: RequestAccountIds, startTime?: string, endTime?: string, minAmount?: string, maxAmount?: string, text?: string, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling listTransactionsSpecificAccounts.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('start-time', <any>startTime);
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('end-time', <any>endTime);
        }
        if (minAmount !== undefined && minAmount !== null) {
            queryParameters = queryParameters.set('min-amount', <any>minAmount);
        }
        if (maxAmount !== undefined && maxAmount !== null) {
            queryParameters = queryParameters.set('max-amount', <any>maxAmount);
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('page-size', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post(`${this.basePath}/banking/accounts/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

