<?php
/**
 * AccountsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
* Consumer Data Standards
 *
* API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right
 *
* OpenAPI spec version: 1-oas3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.4
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * AccountsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AccountsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }
    /**
     * Operation getAccountDetail
*
     * Get Account Detail
*
* @param  string $account_id A tokenised identifier for the account which is unique but not shareable (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBankingAccount
     */
    public function getAccountDetail($account_id)
    {
        list($response) = $this->getAccountDetailWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getAccountDetailWithHttpInfo
*
     * Get Account Detail
*
* @param  string $account_id A tokenised identifier for the account which is unique but not shareable (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBankingAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountDetailWithHttpInfo($account_id)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingAccount';
        $request = $this->getAccountDetailRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ResponseBankingAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation getAccountDetailAsync
     *
     * Get Account Detail
     *
* @param  string $account_id A tokenised identifier for the account which is unique but not shareable (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountDetailAsync($account_id)
    {
        return $this->getAccountDetailAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountDetailAsyncWithHttpInfo
     *
     * Get Account Detail
     *
* @param  string $account_id A tokenised identifier for the account which is unique but not shareable (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountDetailAsyncWithHttpInfo($account_id)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingAccount';
        $request = $this->getAccountDetailRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountDetail'
     *
* @param  string $account_id A tokenised identifier for the account which is unique but not shareable (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountDetailRequest($account_id)
    {
// verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAccountDetail'
            );
        }
$resourcePath = '/banking/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// path params
if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactionDetail
*
     * Get Transaction Detail
*
* @param  string $account_id The account id token that is used to uniquely represent the account (required)
* @param  string $transaction_id The unique identifier for the specific transaction for which details are being requested (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBankingTransactionDetail
     */
    public function getTransactionDetail($account_id, $transaction_id)
    {
        list($response) = $this->getTransactionDetailWithHttpInfo($account_id, $transaction_id);
        return $response;
    }

    /**
     * Operation getTransactionDetailWithHttpInfo
*
     * Get Transaction Detail
*
* @param  string $account_id The account id token that is used to uniquely represent the account (required)
* @param  string $transaction_id The unique identifier for the specific transaction for which details are being requested (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBankingTransactionDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionDetailWithHttpInfo($account_id, $transaction_id)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingTransactionDetail';
        $request = $this->getTransactionDetailRequest($account_id, $transaction_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ResponseBankingTransactionDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation getTransactionDetailAsync
     *
     * Get Transaction Detail
     *
* @param  string $account_id The account id token that is used to uniquely represent the account (required)
* @param  string $transaction_id The unique identifier for the specific transaction for which details are being requested (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionDetailAsync($account_id, $transaction_id)
    {
        return $this->getTransactionDetailAsyncWithHttpInfo($account_id, $transaction_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionDetailAsyncWithHttpInfo
     *
     * Get Transaction Detail
     *
* @param  string $account_id The account id token that is used to uniquely represent the account (required)
* @param  string $transaction_id The unique identifier for the specific transaction for which details are being requested (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionDetailAsyncWithHttpInfo($account_id, $transaction_id)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingTransactionDetail';
        $request = $this->getTransactionDetailRequest($account_id, $transaction_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactionDetail'
     *
* @param  string $account_id The account id token that is used to uniquely represent the account (required)
* @param  string $transaction_id The unique identifier for the specific transaction for which details are being requested (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransactionDetailRequest($account_id, $transaction_id)
    {
// verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getTransactionDetail'
            );
        }
// verify the required parameter 'transaction_id' is set
        if ($transaction_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling getTransactionDetail'
            );
        }
$resourcePath = '/banking/accounts/{accountId}/transactions/{transactionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// path params
if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
// path params
if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionId' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactions
*
     * Get Transactions For Account
*
* @param  string $account_id ID of the account to get transactions for.  Must have previously been returned by one of the account list end points. (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBankingTransactions
     */
    public function getTransactions($account_id, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        list($response) = $this->getTransactionsWithHttpInfo($account_id, $start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);
        return $response;
    }

    /**
     * Operation getTransactionsWithHttpInfo
*
     * Get Transactions For Account
*
* @param  string $account_id ID of the account to get transactions for.  Must have previously been returned by one of the account list end points. (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBankingTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionsWithHttpInfo($account_id, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingTransactions';
        $request = $this->getTransactionsRequest($account_id, $start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ResponseBankingTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation getTransactionsAsync
     *
     * Get Transactions For Account
     *
* @param  string $account_id ID of the account to get transactions for.  Must have previously been returned by one of the account list end points. (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionsAsync($account_id, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        return $this->getTransactionsAsyncWithHttpInfo($account_id, $start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionsAsyncWithHttpInfo
     *
     * Get Transactions For Account
     *
* @param  string $account_id ID of the account to get transactions for.  Must have previously been returned by one of the account list end points. (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionsAsyncWithHttpInfo($account_id, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingTransactions';
        $request = $this->getTransactionsRequest($account_id, $start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactions'
     *
* @param  string $account_id ID of the account to get transactions for.  Must have previously been returned by one of the account list end points. (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransactionsRequest($account_id, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
// verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getTransactions'
            );
        }
$resourcePath = '/banking/accounts/{accountId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// query params
if ($start_time !== null) {
            $queryParams['start-time'] = ObjectSerializer::toQueryValue($start_time);
        }
// query params
if ($end_time !== null) {
            $queryParams['end-time'] = ObjectSerializer::toQueryValue($end_time);
        }
// query params
if ($min_amount !== null) {
            $queryParams['min-amount'] = ObjectSerializer::toQueryValue($min_amount);
        }
// query params
if ($max_amount !== null) {
            $queryParams['max-amount'] = ObjectSerializer::toQueryValue($max_amount);
        }
// query params
if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text);
        }
// query params
if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
// query params
if ($page_size !== null) {
            $queryParams['page-size'] = ObjectSerializer::toQueryValue($page_size);
        }
// path params
if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAccounts
*
     * Get Accounts
*
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBankingAccounts
     */
    public function listAccounts($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
        list($response) = $this->listAccountsWithHttpInfo($open_status, $is_owned, $product_category, $page, $page_size);
        return $response;
    }

    /**
     * Operation listAccountsWithHttpInfo
*
     * Get Accounts
*
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBankingAccounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAccountsWithHttpInfo($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingAccounts';
        $request = $this->listAccountsRequest($open_status, $is_owned, $product_category, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ResponseBankingAccounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation listAccountsAsync
     *
     * Get Accounts
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountsAsync($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
        return $this->listAccountsAsyncWithHttpInfo($open_status, $is_owned, $product_category, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAccountsAsyncWithHttpInfo
     *
     * Get Accounts
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAccountsAsyncWithHttpInfo($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingAccounts';
        $request = $this->listAccountsRequest($open_status, $is_owned, $product_category, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAccounts'
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAccountsRequest($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
$resourcePath = '/banking/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// query params
if ($open_status !== null) {
            $queryParams['open-status'] = ObjectSerializer::toQueryValue($open_status);
        }
// query params
if ($is_owned !== null) {
            $queryParams['is-owned'] = ObjectSerializer::toQueryValue($is_owned);
        }
// query params
if ($product_category !== null) {
            $queryParams['product-category'] = ObjectSerializer::toQueryValue($product_category);
        }
// query params
if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
// query params
if ($page_size !== null) {
            $queryParams['page-size'] = ObjectSerializer::toQueryValue($page_size);
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBalancesBulk
*
     * Get Bulk Balances
*
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBankingAccountsBalances
     */
    public function listBalancesBulk($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
        list($response) = $this->listBalancesBulkWithHttpInfo($open_status, $is_owned, $product_category, $page, $page_size);
        return $response;
    }

    /**
     * Operation listBalancesBulkWithHttpInfo
*
     * Get Bulk Balances
*
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBankingAccountsBalances, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBalancesBulkWithHttpInfo($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingAccountsBalances';
        $request = $this->listBalancesBulkRequest($open_status, $is_owned, $product_category, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ResponseBankingAccountsBalances',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation listBalancesBulkAsync
     *
     * Get Bulk Balances
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBalancesBulkAsync($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
        return $this->listBalancesBulkAsyncWithHttpInfo($open_status, $is_owned, $product_category, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBalancesBulkAsyncWithHttpInfo
     *
     * Get Bulk Balances
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBalancesBulkAsyncWithHttpInfo($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingAccountsBalances';
        $request = $this->listBalancesBulkRequest($open_status, $is_owned, $product_category, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBalancesBulk'
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listBalancesBulkRequest($open_status = null, $is_owned = null, $product_category = null, $page = null, $page_size = null)
    {
$resourcePath = '/banking/accounts/balances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// query params
if ($open_status !== null) {
            $queryParams['open-status'] = ObjectSerializer::toQueryValue($open_status);
        }
// query params
if ($is_owned !== null) {
            $queryParams['is-owned'] = ObjectSerializer::toQueryValue($is_owned);
        }
// query params
if ($product_category !== null) {
            $queryParams['product-category'] = ObjectSerializer::toQueryValue($product_category);
        }
// query params
if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
// query params
if ($page_size !== null) {
            $queryParams['page-size'] = ObjectSerializer::toQueryValue($page_size);
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBalancesSpecificAccounts
*
     * Get Balances For Specific Accounts
*
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBankingAccountsBalances
     */
    public function listBalancesSpecificAccounts($body)
    {
        list($response) = $this->listBalancesSpecificAccountsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation listBalancesSpecificAccountsWithHttpInfo
*
     * Get Balances For Specific Accounts
*
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBankingAccountsBalances, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBalancesSpecificAccountsWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingAccountsBalances';
        $request = $this->listBalancesSpecificAccountsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ResponseBankingAccountsBalances',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 422:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ErrorList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation listBalancesSpecificAccountsAsync
     *
     * Get Balances For Specific Accounts
     *
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBalancesSpecificAccountsAsync($body)
    {
        return $this->listBalancesSpecificAccountsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBalancesSpecificAccountsAsyncWithHttpInfo
     *
     * Get Balances For Specific Accounts
     *
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBalancesSpecificAccountsAsyncWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingAccountsBalances';
        $request = $this->listBalancesSpecificAccountsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBalancesSpecificAccounts'
     *
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listBalancesSpecificAccountsRequest($body)
    {
// verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling listBalancesSpecificAccounts'
            );
        }
$resourcePath = '/banking/accounts/balances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// body params
        $_tempBody = null;
if (isset($body)) {
            $_tempBody = $body;
        }
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTransactionsBulk
*
     * Get Transactions For Multiple Accounts
*
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBankingTransactions
     */
    public function listTransactionsBulk($open_status = null, $is_owned = null, $product_category = null, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        list($response) = $this->listTransactionsBulkWithHttpInfo($open_status, $is_owned, $product_category, $start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);
        return $response;
    }

    /**
     * Operation listTransactionsBulkWithHttpInfo
*
     * Get Transactions For Multiple Accounts
*
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBankingTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTransactionsBulkWithHttpInfo($open_status = null, $is_owned = null, $product_category = null, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingTransactions';
        $request = $this->listTransactionsBulkRequest($open_status, $is_owned, $product_category, $start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ResponseBankingTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation listTransactionsBulkAsync
     *
     * Get Transactions For Multiple Accounts
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTransactionsBulkAsync($open_status = null, $is_owned = null, $product_category = null, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        return $this->listTransactionsBulkAsyncWithHttpInfo($open_status, $is_owned, $product_category, $start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTransactionsBulkAsyncWithHttpInfo
     *
     * Get Transactions For Multiple Accounts
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTransactionsBulkAsyncWithHttpInfo($open_status = null, $is_owned = null, $product_category = null, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingTransactions';
        $request = $this->listTransactionsBulkRequest($open_status, $is_owned, $product_category, $start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTransactionsBulk'
     *
* @param  string $open_status Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
* @param  string $is_owned Filters accounts based on whether they are owned by the authorised customer (optional)
* @param  string $product_category Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTransactionsBulkRequest($open_status = null, $is_owned = null, $product_category = null, $start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
$resourcePath = '/banking/accounts/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// query params
if ($open_status !== null) {
            $queryParams['open-status'] = ObjectSerializer::toQueryValue($open_status);
        }
// query params
if ($is_owned !== null) {
            $queryParams['is-owned'] = ObjectSerializer::toQueryValue($is_owned);
        }
// query params
if ($product_category !== null) {
            $queryParams['product-category'] = ObjectSerializer::toQueryValue($product_category);
        }
// query params
if ($start_time !== null) {
            $queryParams['start-time'] = ObjectSerializer::toQueryValue($start_time);
        }
// query params
if ($end_time !== null) {
            $queryParams['end-time'] = ObjectSerializer::toQueryValue($end_time);
        }
// query params
if ($min_amount !== null) {
            $queryParams['min-amount'] = ObjectSerializer::toQueryValue($min_amount);
        }
// query params
if ($max_amount !== null) {
            $queryParams['max-amount'] = ObjectSerializer::toQueryValue($max_amount);
        }
// query params
if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text);
        }
// query params
if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
// query params
if ($page_size !== null) {
            $queryParams['page-size'] = ObjectSerializer::toQueryValue($page_size);
        }
// body params
        $_tempBody = null;
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTransactionsSpecificAccounts
*
     * Get Transactions For Specific Accounts
*
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBankingTransactions
     */
    public function listTransactionsSpecificAccounts($body$start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        list($response) = $this->listTransactionsSpecificAccountsWithHttpInfo($body$start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);
        return $response;
    }

    /**
     * Operation listTransactionsSpecificAccountsWithHttpInfo
*
     * Get Transactions For Specific Accounts
*
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBankingTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTransactionsSpecificAccountsWithHttpInfo($body$start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingTransactions';
        $request = $this->listTransactionsSpecificAccountsRequest($body$start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

$responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];


        } catch (ApiException $e) {
            $returnType = '';
            $content = $e->getResponseBody();
            if ($returnType !== '\SplFileObject') {
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }
            switch ($e->getCode()) {
case 200:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ResponseBankingTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
case 422:$data = ObjectSerializer::deserialize(
                        $content,
                        '\Swagger\Client\Model\ErrorList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
}
            throw $e;
        }
    }

    /**
     * Operation listTransactionsSpecificAccountsAsync
     *
     * Get Transactions For Specific Accounts
     *
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTransactionsSpecificAccountsAsync($body$start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        return $this->listTransactionsSpecificAccountsAsyncWithHttpInfo($body$start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTransactionsSpecificAccountsAsyncWithHttpInfo
     *
     * Get Transactions For Specific Accounts
     *
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTransactionsSpecificAccountsAsyncWithHttpInfo($body$start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBankingTransactions';
        $request = $this->listTransactionsSpecificAccountsRequest($body$start_time, $end_time, $min_amount, $max_amount, $text, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
$responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTransactionsSpecificAccounts'
     *
* @param  \Swagger\Client\Model\RequestAccountIds $body The list of account IDs to obtain information for (required)
* @param  string $start_time Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
* @param  string $end_time Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
* @param  string $min_amount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
* @param  string $max_amount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
* @param  string $text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
* @param  int $page Page of results to request (standard pagination) (optional)
* @param  int $page_size Page size to request. Default is 25 (standard pagination) (optional)
*
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTransactionsSpecificAccountsRequest($body$start_time = null, $end_time = null, $min_amount = null, $max_amount = null, $text = null, $page = null, $page_size = null)
    {
// verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling listTransactionsSpecificAccounts'
            );
        }
$resourcePath = '/banking/accounts/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

// query params
if ($start_time !== null) {
            $queryParams['start-time'] = ObjectSerializer::toQueryValue($start_time);
        }
// query params
if ($end_time !== null) {
            $queryParams['end-time'] = ObjectSerializer::toQueryValue($end_time);
        }
// query params
if ($min_amount !== null) {
            $queryParams['min-amount'] = ObjectSerializer::toQueryValue($min_amount);
        }
// query params
if ($max_amount !== null) {
            $queryParams['max-amount'] = ObjectSerializer::toQueryValue($max_amount);
        }
// query params
if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text);
        }
// query params
if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
// query params
if ($page_size !== null) {
            $queryParams['page-size'] = ObjectSerializer::toQueryValue($page_size);
        }
// body params
        $_tempBody = null;
if (isset($body)) {
            $_tempBody = $body;
        }
if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }
$defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

/**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
