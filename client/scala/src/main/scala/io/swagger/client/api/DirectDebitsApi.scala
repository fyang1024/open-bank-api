/**
 * Consumer Data Standards
 * API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right
 *
 * OpenAPI spec version: 1-oas3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.ErrorList
import io.swagger.client.model.RequestAccountIds
import io.swagger.client.model.ResponseBankingDirectDebits
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class DirectDebitsApi(
  val defBasePath: String = "https://data.provider.com.au/cds-au/v1",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new DirectDebitsApiAsyncHelper(client, config)

  /**
   * Get Direct Debits For Account
   * Obtain direct debit authorisations for a specific account
   *
   * @param accountId ID of the account to get direct debit authorisations for.  Must have previously been returned by one of the account list end points. 
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return ResponseBankingDirectDebits
   */
  def listDirectDebits(accountId: String, page: Option[Integer] = None, pageSize: Option[Integer] = None): Option[ResponseBankingDirectDebits] = {
    val await = Try(Await.result(listDirectDebitsAsync(accountId, page, pageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Direct Debits For Account asynchronously
   * Obtain direct debit authorisations for a specific account
   *
   * @param accountId ID of the account to get direct debit authorisations for.  Must have previously been returned by one of the account list end points. 
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return Future(ResponseBankingDirectDebits)
   */
  def listDirectDebitsAsync(accountId: String, page: Option[Integer] = None, pageSize: Option[Integer] = None): Future[ResponseBankingDirectDebits] = {
      helper.listDirectDebits(accountId, page, pageSize)
  }

  /**
   * Get Bulk Direct Debits
   * Obtain direct debit authorisations for multiple, filtered accounts
   *
   * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return ResponseBankingDirectDebits
   */
  def listDirectDebitsBulk(isOwned: Option[String] = None, productCategory: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Option[ResponseBankingDirectDebits] = {
    val await = Try(Await.result(listDirectDebitsBulkAsync(isOwned, productCategory, page, pageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Bulk Direct Debits asynchronously
   * Obtain direct debit authorisations for multiple, filtered accounts
   *
   * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return Future(ResponseBankingDirectDebits)
   */
  def listDirectDebitsBulkAsync(isOwned: Option[String] = None, productCategory: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Future[ResponseBankingDirectDebits] = {
      helper.listDirectDebitsBulk(isOwned, productCategory, page, pageSize)
  }

  /**
   * Get Direct Debits For Specific Accounts
   * Obtain direct debit authorisations for a specified list of accounts
   *
   * @param body The list of account IDs to obtain information for 
   * @return ResponseBankingDirectDebits
   */
  def listDirectDebitsSpecificAccounts(body: RequestAccountIds): Option[ResponseBankingDirectDebits] = {
    val await = Try(Await.result(listDirectDebitsSpecificAccountsAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Direct Debits For Specific Accounts asynchronously
   * Obtain direct debit authorisations for a specified list of accounts
   *
   * @param body The list of account IDs to obtain information for 
   * @return Future(ResponseBankingDirectDebits)
   */
  def listDirectDebitsSpecificAccountsAsync(body: RequestAccountIds): Future[ResponseBankingDirectDebits] = {
      helper.listDirectDebitsSpecificAccounts(body)
  }

}

class DirectDebitsApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def listDirectDebits(accountId: String,
    page: Option[Integer] = None,
    pageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ResponseBankingDirectDebits]): Future[ResponseBankingDirectDebits] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/{accountId}/direct-debits")
      replaceAll("\\{" + "accountId" + "\\}", accountId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (accountId == null) throw new Exception("Missing required parameter 'accountId' when calling DirectDebitsApi->listDirectDebits")

    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page-size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listDirectDebitsBulk(isOwned: Option[String] = None,
    productCategory: Option[String] = None,
    page: Option[Integer] = None,
    pageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ResponseBankingDirectDebits]): Future[ResponseBankingDirectDebits] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/direct-debits"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    isOwned match {
      case Some(param) => queryParams += "is-owned" -> param.toString
      case _ => queryParams
    }
    productCategory match {
      case Some(param) => queryParams += "product-category" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page-size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listDirectDebitsSpecificAccounts(body: RequestAccountIds)(implicit reader: ClientResponseReader[ResponseBankingDirectDebits], writer: RequestWriter[RequestAccountIds]): Future[ResponseBankingDirectDebits] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/direct-debits"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling DirectDebitsApi->listDirectDebitsSpecificAccounts")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
