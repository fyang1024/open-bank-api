/**
 * Consumer Data Standards
 * API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right
 *
 * OpenAPI spec version: 1-oas3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.ResponseBankingProduct
import io.swagger.client.model.ResponseBankingProducts
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class ProductsApi(
  val defBasePath: String = "https://data.provider.com.au/cds-au/v1",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new ProductsApiAsyncHelper(client, config)

  /**
   * Get Product Detail
   * Obtain detailed information on a single product offered openly to the market
   *
   * @param productId ID of the specific product requested 
   * @return ResponseBankingProduct
   */
  def getProductDetail(productId: String): Option[ResponseBankingProduct] = {
    val await = Try(Await.result(getProductDetailAsync(productId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Product Detail asynchronously
   * Obtain detailed information on a single product offered openly to the market
   *
   * @param productId ID of the specific product requested 
   * @return Future(ResponseBankingProduct)
   */
  def getProductDetailAsync(productId: String): Future[ResponseBankingProduct] = {
      helper.getProductDetail(productId)
  }

  /**
   * Get Products
   * Obtain a list of products that are currently openly offered to the market
   *
   * @param effective Allows for the filtering of products based on whether the current time is within the period of time defined as effective by the effectiveFrom and effectiveTo fields.  If absent defaults to &#39;CURRENT&#39; (optional)
   * @param updatedSince Only include products that have been updated after the specified date and time. If absent defaults to include all products (optional)
   * @param brand Filter results based on a specific brand (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return ResponseBankingProducts
   */
  def listProducts(effective: Option[String] = None, updatedSince: Option[String] = None, brand: Option[String] = None, productCategory: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Option[ResponseBankingProducts] = {
    val await = Try(Await.result(listProductsAsync(effective, updatedSince, brand, productCategory, page, pageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Products asynchronously
   * Obtain a list of products that are currently openly offered to the market
   *
   * @param effective Allows for the filtering of products based on whether the current time is within the period of time defined as effective by the effectiveFrom and effectiveTo fields.  If absent defaults to &#39;CURRENT&#39; (optional)
   * @param updatedSince Only include products that have been updated after the specified date and time. If absent defaults to include all products (optional)
   * @param brand Filter results based on a specific brand (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return Future(ResponseBankingProducts)
   */
  def listProductsAsync(effective: Option[String] = None, updatedSince: Option[String] = None, brand: Option[String] = None, productCategory: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Future[ResponseBankingProducts] = {
      helper.listProducts(effective, updatedSince, brand, productCategory, page, pageSize)
  }

}

class ProductsApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def getProductDetail(productId: String)(implicit reader: ClientResponseReader[ResponseBankingProduct]): Future[ResponseBankingProduct] = {
    // create path and map variables
    val path = (addFmt("/banking/products/{productId}")
      replaceAll("\\{" + "productId" + "\\}", productId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (productId == null) throw new Exception("Missing required parameter 'productId' when calling ProductsApi->getProductDetail")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listProducts(effective: Option[String] = None,
    updatedSince: Option[String] = None,
    brand: Option[String] = None,
    productCategory: Option[String] = None,
    page: Option[Integer] = None,
    pageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ResponseBankingProducts]): Future[ResponseBankingProducts] = {
    // create path and map variables
    val path = (addFmt("/banking/products"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    effective match {
      case Some(param) => queryParams += "effective" -> param.toString
      case _ => queryParams
    }
    updatedSince match {
      case Some(param) => queryParams += "updated-since" -> param.toString
      case _ => queryParams
    }
    brand match {
      case Some(param) => queryParams += "brand" -> param.toString
      case _ => queryParams
    }
    productCategory match {
      case Some(param) => queryParams += "product-category" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page-size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
