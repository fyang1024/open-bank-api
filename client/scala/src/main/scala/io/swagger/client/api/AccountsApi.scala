/**
 * Consumer Data Standards
 * API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right
 *
 * OpenAPI spec version: 1-oas3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.ErrorList
import io.swagger.client.model.RequestAccountIds
import io.swagger.client.model.ResponseBankingAccount
import io.swagger.client.model.ResponseBankingAccounts
import io.swagger.client.model.ResponseBankingAccountsBalances
import io.swagger.client.model.ResponseBankingTransactionDetail
import io.swagger.client.model.ResponseBankingTransactions
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class AccountsApi(
  val defBasePath: String = "https://data.provider.com.au/cds-au/v1",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new AccountsApiAsyncHelper(client, config)

  /**
   * Get Account Detail
   * Obtain detailed information on a single account
   *
   * @param accountId A tokenised identifier for the account which is unique but not shareable 
   * @return ResponseBankingAccount
   */
  def getAccountDetail(accountId: String): Option[ResponseBankingAccount] = {
    val await = Try(Await.result(getAccountDetailAsync(accountId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Account Detail asynchronously
   * Obtain detailed information on a single account
   *
   * @param accountId A tokenised identifier for the account which is unique but not shareable 
   * @return Future(ResponseBankingAccount)
   */
  def getAccountDetailAsync(accountId: String): Future[ResponseBankingAccount] = {
      helper.getAccountDetail(accountId)
  }

  /**
   * Get Transaction Detail
   * Obtain detailed information on a transaction for a specific account
   *
   * @param accountId The account id token that is used to uniquely represent the account 
   * @param transactionId The unique identifier for the specific transaction for which details are being requested 
   * @return ResponseBankingTransactionDetail
   */
  def getTransactionDetail(accountId: String, transactionId: String): Option[ResponseBankingTransactionDetail] = {
    val await = Try(Await.result(getTransactionDetailAsync(accountId, transactionId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Transaction Detail asynchronously
   * Obtain detailed information on a transaction for a specific account
   *
   * @param accountId The account id token that is used to uniquely represent the account 
   * @param transactionId The unique identifier for the specific transaction for which details are being requested 
   * @return Future(ResponseBankingTransactionDetail)
   */
  def getTransactionDetailAsync(accountId: String, transactionId: String): Future[ResponseBankingTransactionDetail] = {
      helper.getTransactionDetail(accountId, transactionId)
  }

  /**
   * Get Transactions For Account
   * Obtain transactions for a specific account
   *
   * @param accountId ID of the account to get transactions for.  Must have previously been returned by one of the account list end points. 
   * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
   * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
   * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
   * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
   * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return ResponseBankingTransactions
   */
  def getTransactions(accountId: String, startTime: Option[String] = None, endTime: Option[String] = None, minAmount: Option[String] = None, maxAmount: Option[String] = None, text: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Option[ResponseBankingTransactions] = {
    val await = Try(Await.result(getTransactionsAsync(accountId, startTime, endTime, minAmount, maxAmount, text, page, pageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Transactions For Account asynchronously
   * Obtain transactions for a specific account
   *
   * @param accountId ID of the account to get transactions for.  Must have previously been returned by one of the account list end points. 
   * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
   * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
   * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
   * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
   * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return Future(ResponseBankingTransactions)
   */
  def getTransactionsAsync(accountId: String, startTime: Option[String] = None, endTime: Option[String] = None, minAmount: Option[String] = None, maxAmount: Option[String] = None, text: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Future[ResponseBankingTransactions] = {
      helper.getTransactions(accountId, startTime, endTime, minAmount, maxAmount, text, page, pageSize)
  }

  /**
   * Get Accounts
   * Obtain a list of accounts
   *
   * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
   * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return ResponseBankingAccounts
   */
  def listAccounts(openStatus: Option[String] = None, isOwned: Option[String] = None, productCategory: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Option[ResponseBankingAccounts] = {
    val await = Try(Await.result(listAccountsAsync(openStatus, isOwned, productCategory, page, pageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Accounts asynchronously
   * Obtain a list of accounts
   *
   * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
   * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return Future(ResponseBankingAccounts)
   */
  def listAccountsAsync(openStatus: Option[String] = None, isOwned: Option[String] = None, productCategory: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Future[ResponseBankingAccounts] = {
      helper.listAccounts(openStatus, isOwned, productCategory, page, pageSize)
  }

  /**
   * Get Bulk Balances
   * Obtain balances for multiple, filtered accounts
   *
   * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
   * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return ResponseBankingAccountsBalances
   */
  def listBalancesBulk(openStatus: Option[String] = None, isOwned: Option[String] = None, productCategory: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Option[ResponseBankingAccountsBalances] = {
    val await = Try(Await.result(listBalancesBulkAsync(openStatus, isOwned, productCategory, page, pageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Bulk Balances asynchronously
   * Obtain balances for multiple, filtered accounts
   *
   * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
   * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return Future(ResponseBankingAccountsBalances)
   */
  def listBalancesBulkAsync(openStatus: Option[String] = None, isOwned: Option[String] = None, productCategory: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Future[ResponseBankingAccountsBalances] = {
      helper.listBalancesBulk(openStatus, isOwned, productCategory, page, pageSize)
  }

  /**
   * Get Balances For Specific Accounts
   * Obtain balances for a specified list of accounts
   *
   * @param body The list of account IDs to obtain information for 
   * @return ResponseBankingAccountsBalances
   */
  def listBalancesSpecificAccounts(body: RequestAccountIds): Option[ResponseBankingAccountsBalances] = {
    val await = Try(Await.result(listBalancesSpecificAccountsAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Balances For Specific Accounts asynchronously
   * Obtain balances for a specified list of accounts
   *
   * @param body The list of account IDs to obtain information for 
   * @return Future(ResponseBankingAccountsBalances)
   */
  def listBalancesSpecificAccountsAsync(body: RequestAccountIds): Future[ResponseBankingAccountsBalances] = {
      helper.listBalancesSpecificAccounts(body)
  }

  /**
   * Get Transactions For Multiple Accounts
   * Obtain transactions for multiple, filtered accounts
   *
   * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
   * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
   * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
   * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
   * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
   * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return ResponseBankingTransactions
   */
  def listTransactionsBulk(openStatus: Option[String] = None, isOwned: Option[String] = None, productCategory: Option[String] = None, startTime: Option[String] = None, endTime: Option[String] = None, minAmount: Option[String] = None, maxAmount: Option[String] = None, text: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Option[ResponseBankingTransactions] = {
    val await = Try(Await.result(listTransactionsBulkAsync(openStatus, isOwned, productCategory, startTime, endTime, minAmount, maxAmount, text, page, pageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Transactions For Multiple Accounts asynchronously
   * Obtain transactions for multiple, filtered accounts
   *
   * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
   * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
   * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
   * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
   * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
   * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
   * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
   * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return Future(ResponseBankingTransactions)
   */
  def listTransactionsBulkAsync(openStatus: Option[String] = None, isOwned: Option[String] = None, productCategory: Option[String] = None, startTime: Option[String] = None, endTime: Option[String] = None, minAmount: Option[String] = None, maxAmount: Option[String] = None, text: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Future[ResponseBankingTransactions] = {
      helper.listTransactionsBulk(openStatus, isOwned, productCategory, startTime, endTime, minAmount, maxAmount, text, page, pageSize)
  }

  /**
   * Get Transactions For Specific Accounts
   * Obtain transactions for a specified list of transactions.
   *
   * @param body The list of account IDs to obtain information for 
   * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
   * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
   * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
   * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
   * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return ResponseBankingTransactions
   */
  def listTransactionsSpecificAccounts(body: RequestAccountIdsstartTime: Option[String] = None, endTime: Option[String] = None, minAmount: Option[String] = None, maxAmount: Option[String] = None, text: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Option[ResponseBankingTransactions] = {
    val await = Try(Await.result(listTransactionsSpecificAccountsAsync(bodystartTime, endTime, minAmount, maxAmount, text, page, pageSize), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Transactions For Specific Accounts asynchronously
   * Obtain transactions for a specified list of transactions.
   *
   * @param body The list of account IDs to obtain information for 
   * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
   * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
   * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
   * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
   * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
   * @param page Page of results to request (standard pagination) (optional)
   * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
   * @return Future(ResponseBankingTransactions)
   */
  def listTransactionsSpecificAccountsAsync(body: RequestAccountIdsstartTime: Option[String] = None, endTime: Option[String] = None, minAmount: Option[String] = None, maxAmount: Option[String] = None, text: Option[String] = None, page: Option[Integer] = None, pageSize: Option[Integer] = None): Future[ResponseBankingTransactions] = {
      helper.listTransactionsSpecificAccounts(bodystartTime, endTime, minAmount, maxAmount, text, page, pageSize)
  }

}

class AccountsApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def getAccountDetail(accountId: String)(implicit reader: ClientResponseReader[ResponseBankingAccount]): Future[ResponseBankingAccount] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/{accountId}")
      replaceAll("\\{" + "accountId" + "\\}", accountId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (accountId == null) throw new Exception("Missing required parameter 'accountId' when calling AccountsApi->getAccountDetail")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getTransactionDetail(accountId: String,
    transactionId: String)(implicit reader: ClientResponseReader[ResponseBankingTransactionDetail]): Future[ResponseBankingTransactionDetail] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/{accountId}/transactions/{transactionId}")
      replaceAll("\\{" + "accountId" + "\\}", accountId.toString)
      replaceAll("\\{" + "transactionId" + "\\}", transactionId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (accountId == null) throw new Exception("Missing required parameter 'accountId' when calling AccountsApi->getTransactionDetail")

    if (transactionId == null) throw new Exception("Missing required parameter 'transactionId' when calling AccountsApi->getTransactionDetail")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getTransactions(accountId: String,
    startTime: Option[String] = None,
    endTime: Option[String] = None,
    minAmount: Option[String] = None,
    maxAmount: Option[String] = None,
    text: Option[String] = None,
    page: Option[Integer] = None,
    pageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ResponseBankingTransactions]): Future[ResponseBankingTransactions] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/{accountId}/transactions")
      replaceAll("\\{" + "accountId" + "\\}", accountId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (accountId == null) throw new Exception("Missing required parameter 'accountId' when calling AccountsApi->getTransactions")

    startTime match {
      case Some(param) => queryParams += "start-time" -> param.toString
      case _ => queryParams
    }
    endTime match {
      case Some(param) => queryParams += "end-time" -> param.toString
      case _ => queryParams
    }
    minAmount match {
      case Some(param) => queryParams += "min-amount" -> param.toString
      case _ => queryParams
    }
    maxAmount match {
      case Some(param) => queryParams += "max-amount" -> param.toString
      case _ => queryParams
    }
    text match {
      case Some(param) => queryParams += "text" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page-size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listAccounts(openStatus: Option[String] = None,
    isOwned: Option[String] = None,
    productCategory: Option[String] = None,
    page: Option[Integer] = None,
    pageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ResponseBankingAccounts]): Future[ResponseBankingAccounts] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    openStatus match {
      case Some(param) => queryParams += "open-status" -> param.toString
      case _ => queryParams
    }
    isOwned match {
      case Some(param) => queryParams += "is-owned" -> param.toString
      case _ => queryParams
    }
    productCategory match {
      case Some(param) => queryParams += "product-category" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page-size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listBalancesBulk(openStatus: Option[String] = None,
    isOwned: Option[String] = None,
    productCategory: Option[String] = None,
    page: Option[Integer] = None,
    pageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ResponseBankingAccountsBalances]): Future[ResponseBankingAccountsBalances] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/balances"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    openStatus match {
      case Some(param) => queryParams += "open-status" -> param.toString
      case _ => queryParams
    }
    isOwned match {
      case Some(param) => queryParams += "is-owned" -> param.toString
      case _ => queryParams
    }
    productCategory match {
      case Some(param) => queryParams += "product-category" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page-size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listBalancesSpecificAccounts(body: RequestAccountIds)(implicit reader: ClientResponseReader[ResponseBankingAccountsBalances], writer: RequestWriter[RequestAccountIds]): Future[ResponseBankingAccountsBalances] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/balances"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountsApi->listBalancesSpecificAccounts")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listTransactionsBulk(openStatus: Option[String] = None,
    isOwned: Option[String] = None,
    productCategory: Option[String] = None,
    startTime: Option[String] = None,
    endTime: Option[String] = None,
    minAmount: Option[String] = None,
    maxAmount: Option[String] = None,
    text: Option[String] = None,
    page: Option[Integer] = None,
    pageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ResponseBankingTransactions]): Future[ResponseBankingTransactions] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/transactions"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    openStatus match {
      case Some(param) => queryParams += "open-status" -> param.toString
      case _ => queryParams
    }
    isOwned match {
      case Some(param) => queryParams += "is-owned" -> param.toString
      case _ => queryParams
    }
    productCategory match {
      case Some(param) => queryParams += "product-category" -> param.toString
      case _ => queryParams
    }
    startTime match {
      case Some(param) => queryParams += "start-time" -> param.toString
      case _ => queryParams
    }
    endTime match {
      case Some(param) => queryParams += "end-time" -> param.toString
      case _ => queryParams
    }
    minAmount match {
      case Some(param) => queryParams += "min-amount" -> param.toString
      case _ => queryParams
    }
    maxAmount match {
      case Some(param) => queryParams += "max-amount" -> param.toString
      case _ => queryParams
    }
    text match {
      case Some(param) => queryParams += "text" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page-size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listTransactionsSpecificAccounts(body: RequestAccountIdsstartTime: Option[String] = None,
    endTime: Option[String] = None,
    minAmount: Option[String] = None,
    maxAmount: Option[String] = None,
    text: Option[String] = None,
    page: Option[Integer] = None,
    pageSize: Option[Integer] = None
    )(implicit reader: ClientResponseReader[ResponseBankingTransactions], writer: RequestWriter[RequestAccountIds]): Future[ResponseBankingTransactions] = {
    // create path and map variables
    val path = (addFmt("/banking/accounts/transactions"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling AccountsApi->listTransactionsSpecificAccounts")
    startTime match {
      case Some(param) => queryParams += "start-time" -> param.toString
      case _ => queryParams
    }
    endTime match {
      case Some(param) => queryParams += "end-time" -> param.toString
      case _ => queryParams
    }
    minAmount match {
      case Some(param) => queryParams += "min-amount" -> param.toString
      case _ => queryParams
    }
    maxAmount match {
      case Some(param) => queryParams += "max-amount" -> param.toString
      case _ => queryParams
    }
    text match {
      case Some(param) => queryParams += "text" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "page-size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
