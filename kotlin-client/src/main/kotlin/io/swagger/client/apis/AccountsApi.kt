/**
* Consumer Data Standards
* API sets created by the Australian Consumer Data Standards to meet the needs of the Consumer Data Right
*
* OpenAPI spec version: 1-oas3
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.ErrorList
import io.swagger.client.models.RequestAccountIds
import io.swagger.client.models.ResponseBankingAccount
import io.swagger.client.models.ResponseBankingAccounts
import io.swagger.client.models.ResponseBankingAccountsBalances
import io.swagger.client.models.ResponseBankingTransactionDetail
import io.swagger.client.models.ResponseBankingTransactions

import io.swagger.client.infrastructure.*

class AccountsApi(basePath: kotlin.String = "https://data.provider.com.au/cds-au/v1") : ApiClient(basePath) {

    /**
    * Get Account Detail
    * Obtain detailed information on a single account
    * @param accountId A tokenised identifier for the account which is unique but not shareable 
    * @return ResponseBankingAccount
    */
    @Suppress("UNCHECKED_CAST")
    fun getAccountDetail(accountId: kotlin.String) : ResponseBankingAccount {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/banking/accounts/{accountId}".replace("{"+"accountId"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseBankingAccount>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseBankingAccount
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get Transaction Detail
    * Obtain detailed information on a transaction for a specific account
    * @param accountId The account id token that is used to uniquely represent the account 
    * @param transactionId The unique identifier for the specific transaction for which details are being requested 
    * @return ResponseBankingTransactionDetail
    */
    @Suppress("UNCHECKED_CAST")
    fun getTransactionDetail(accountId: kotlin.String, transactionId: kotlin.String) : ResponseBankingTransactionDetail {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/banking/accounts/{accountId}/transactions/{transactionId}".replace("{"+"accountId"+"}", "$accountId").replace("{"+"transactionId"+"}", "$transactionId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseBankingTransactionDetail>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseBankingTransactionDetail
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get Transactions For Account
    * Obtain transactions for a specific account
    * @param accountId ID of the account to get transactions for.  Must have previously been returned by one of the account list end points. 
    * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
    * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
    * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
    * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
    * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
    * @param page Page of results to request (standard pagination) (optional)
    * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
    * @return ResponseBankingTransactions
    */
    @Suppress("UNCHECKED_CAST")
    fun getTransactions(accountId: kotlin.String, startTime: kotlin.String, endTime: kotlin.String, minAmount: kotlin.String, maxAmount: kotlin.String, text: kotlin.String, page: kotlin.Int, pageSize: kotlin.Int) : ResponseBankingTransactions {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("start-time" to listOf("$startTime"), "end-time" to listOf("$endTime"), "min-amount" to listOf("$minAmount"), "max-amount" to listOf("$maxAmount"), "text" to listOf("$text"), "page" to listOf("$page"), "page-size" to listOf("$pageSize"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/banking/accounts/{accountId}/transactions".replace("{"+"accountId"+"}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseBankingTransactions>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseBankingTransactions
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get Accounts
    * Obtain a list of accounts
    * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
    * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
    * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
    * @param page Page of results to request (standard pagination) (optional)
    * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
    * @return ResponseBankingAccounts
    */
    @Suppress("UNCHECKED_CAST")
    fun listAccounts(openStatus: kotlin.String, isOwned: kotlin.String, productCategory: kotlin.String, page: kotlin.Int, pageSize: kotlin.Int) : ResponseBankingAccounts {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("open-status" to listOf("$openStatus"), "is-owned" to listOf("$isOwned"), "product-category" to listOf("$productCategory"), "page" to listOf("$page"), "page-size" to listOf("$pageSize"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/banking/accounts",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseBankingAccounts>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseBankingAccounts
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get Bulk Balances
    * Obtain balances for multiple, filtered accounts
    * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
    * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
    * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
    * @param page Page of results to request (standard pagination) (optional)
    * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
    * @return ResponseBankingAccountsBalances
    */
    @Suppress("UNCHECKED_CAST")
    fun listBalancesBulk(openStatus: kotlin.String, isOwned: kotlin.String, productCategory: kotlin.String, page: kotlin.Int, pageSize: kotlin.Int) : ResponseBankingAccountsBalances {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("open-status" to listOf("$openStatus"), "is-owned" to listOf("$isOwned"), "product-category" to listOf("$productCategory"), "page" to listOf("$page"), "page-size" to listOf("$pageSize"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/banking/accounts/balances",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseBankingAccountsBalances>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseBankingAccountsBalances
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get Balances For Specific Accounts
    * Obtain balances for a specified list of accounts
    * @param body The list of account IDs to obtain information for 
    * @return ResponseBankingAccountsBalances
    */
    @Suppress("UNCHECKED_CAST")
    fun listBalancesSpecificAccounts(body: RequestAccountIds) : ResponseBankingAccountsBalances {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/banking/accounts/balances",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseBankingAccountsBalances>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseBankingAccountsBalances
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get Transactions For Multiple Accounts
    * Obtain transactions for multiple, filtered accounts
    * @param openStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed (optional)
    * @param isOwned Filters accounts based on whether they are owned by the authorised customer (optional)
    * @param productCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned. (optional)
    * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
    * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
    * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
    * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
    * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
    * @param page Page of results to request (standard pagination) (optional)
    * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
    * @return ResponseBankingTransactions
    */
    @Suppress("UNCHECKED_CAST")
    fun listTransactionsBulk(openStatus: kotlin.String, isOwned: kotlin.String, productCategory: kotlin.String, startTime: kotlin.String, endTime: kotlin.String, minAmount: kotlin.String, maxAmount: kotlin.String, text: kotlin.String, page: kotlin.Int, pageSize: kotlin.Int) : ResponseBankingTransactions {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("open-status" to listOf("$openStatus"), "is-owned" to listOf("$isOwned"), "product-category" to listOf("$productCategory"), "start-time" to listOf("$startTime"), "end-time" to listOf("$endTime"), "min-amount" to listOf("$minAmount"), "max-amount" to listOf("$maxAmount"), "text" to listOf("$text"), "page" to listOf("$page"), "page-size" to listOf("$pageSize"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/banking/accounts/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseBankingTransactions>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseBankingTransactions
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Get Transactions For Specific Accounts
    * Obtain transactions for a specified list of transactions.
    * @param body The list of account IDs to obtain information for 
    * @param startTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to current time. Format is aligned to DateTimeString common type (optional)
    * @param endTime Constrain the transaction history request to transactions with effective time at or before this date/time. If absent defaults to start-time plus 100 days. Format is aligned to DateTimeString common type (optional)
    * @param minAmount Filter transactions to only transactions with amounts higher or equal to than this amount (optional)
    * @param maxAmount Filter transactions to only transactions with amounts less than or equal to than this amount (optional)
    * @param text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string (optional)
    * @param page Page of results to request (standard pagination) (optional)
    * @param pageSize Page size to request. Default is 25 (standard pagination) (optional)
    * @return ResponseBankingTransactions
    */
    @Suppress("UNCHECKED_CAST")
    fun listTransactionsSpecificAccounts(body: RequestAccountIdsstartTime: kotlin.String, endTime: kotlin.String, minAmount: kotlin.String, maxAmount: kotlin.String, text: kotlin.String, page: kotlin.Int, pageSize: kotlin.Int) : ResponseBankingTransactions {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("start-time" to listOf("$startTime"), "end-time" to listOf("$endTime"), "min-amount" to listOf("$minAmount"), "max-amount" to listOf("$maxAmount"), "text" to listOf("$text"), "page" to listOf("$page"), "page-size" to listOf("$pageSize"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/banking/accounts/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseBankingTransactions>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseBankingTransactions
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
